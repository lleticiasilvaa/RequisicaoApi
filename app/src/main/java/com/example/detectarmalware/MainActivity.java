package com.example.detectarmalware;

import static com.google.firebase.crashlytics.buildtools.reloc.org.apache.http.conn.ssl.SSLConnectionSocketFactory.SSL;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import android.content.Context;
import android.content.Intent;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.ArrayAdapter;

import com.google.firebase.crashlytics.buildtools.reloc.org.apache.http.HttpEntity;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.security.cert.CertificateException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;
import java.util.Locale;
import java.util.UUID;

import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;

import java.io.IOException;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class MainActivity extends AppCompatActivity {
    private String ID;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Requisicao requisicao = new Requisicao();
        requisicao.execute("http://192.168.100.193:5000/androidStudio");



//
////        //coletar ID
////        ID = UUID.randomUUID().toString();
////        //salvaiID arquivo
////        writeID(ID);
////        System.out.println("\nOi");
//
//        // Criar um cliente OkHttp
//        OkHttpClient client = new OkHttpClient();
//
//        // Construir a URL completa para a rota /androidStudio
//        String url = "http://192.168.100.193:5000/androidStudio";
//
//        // Criar uma solicitação GET para a rota /androidStudio
//        Request request = new Request.Builder()
//                .url(url)
//                .build();
//
//        // Executar a solicitação em uma thread em segundo plano
//        client.newCall(request).enqueue(new Callback() {
//            @Override
//            public void onFailure(Call call, IOException e) {
//                // Lidar com falhas na solicitação
//                e.printStackTrace();
//                System.out.println("Erro =(:");
//            }
//
//            @Override
//            public void onResponse(Call call, Response response) throws IOException {
//                // Lidar com a resposta bem-sucedida
//                final String responseData = response.body().string();
//
//                System.out.println("Resposta:"+responseData );
//            }
//        });

    }

    public class Requisicao extends AsyncTask<String ,String, String>{

        @Override
        public String doInBackground(String... strings){
            String retorno = Conexao.getDados(strings[0]);
            return retorno;
        }

        @Override
        protected void onPostExecute(String s) {
            System.out.println(s);
        }
    }


//    protected void onStart() {
//        super.onStart();
//
//        Calendar calendarStart = Calendar.getInstance();
//        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss", Locale.getDefault());
//        String dataAtual = simpleDateFormat.format(calendarStart.getTime()).substring(0,10);;
//
//
//        ArrayList<String> dados = new ArrayList<>();
//        lerDados( "user.csv", dados);
//        lerDados( "pacotes.csv", dados);
////        Log.i("MainActivity/onStart()", "Dados aqui " + dados);
//
//        if(!(dados.contains(dataAtual))) {
//            infosUser(dataAtual);
//        }
//
//        //coletarListaApps(dados);
//        coletarApps();
//    }

    //salvar id no armazenamento interno
    private void writeID(String ID) {
        String FILE_NAME = "ID.csv";
        FileOutputStream fos = null;
        try {
            fos = openFileOutput(FILE_NAME, MODE_PRIVATE);
            fos.write((ID + "s\n").getBytes());
            Log.i("MainActivity/saveGps()", "Saved to " + getFilesDir() + "/" + FILE_NAME); //mostrar onde arquivo foi salvo
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    //coletar lista de aplicativos e salvar no armazenamento interno
    private void coletarListaApps(ArrayList<String> dados) {
        //coletar lista de aplicativo
        List<ApplicationInfo> applicationInfoList = getPackageManager().getInstalledApplications(PackageManager.GET_META_DATA);
        String[] stringsArray = new String[applicationInfoList.size()];
        int i = 0;
        for (ApplicationInfo applicationInfo : applicationInfoList) {
            // so irá salvar se o aplicativo já não foi registrado anteriormente
            if(!(dados.contains(applicationInfo.packageName))){
                stringsArray[i] = applicationInfo.packageName;
            }
            i++;
        }
        Log.i("MainActivity/apps()", "lista aplicativos coletada");

        //salvar lista de apps no armazenamento interno:
        String FILE_NAME;
        FILE_NAME = "pacotes.csv";
        FileOutputStream fos = null;
        try {
            fos = openFileOutput(FILE_NAME, MODE_APPEND);
            for (i = 0; i < applicationInfoList.size(); i++) {
                fos.write((stringsArray[i] + "\n").getBytes());
            }
            System.out.print("\nSaved to " + getFilesDir() + "/" + FILE_NAME);
            Log.i("MainActivity/saveApps()", "Saved to " + getFilesDir() + "/" + FILE_NAME); //mostrar onde arquivo foi salvo
        } catch (IOException e) {
            e.printStackTrace();
            Log.e("MainActivity/saveGps()", "Erro: salvar no arquivo pacotes.csv");
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        // salvar lista de permissoes do apps
        FileOutputStream fosPermission = null;
        FILE_NAME = ("permissions.csv");
        for (String packageName : stringsArray) {
            try {
                PackageInfo packageInfo = getPackageManager().getPackageInfo(packageName, PackageManager.GET_PERMISSIONS);
                String[] permissions = packageInfo.requestedPermissions;
                fosPermission = openFileOutput(FILE_NAME, MODE_APPEND);

                System.out.println("Permissoes do" + packageName + ":");
                //requisição para o flask
                fazerRequisicao(packageName, permissions);



                if (permissions != null) {
                    fosPermission.write(("\nPACKAGE " + packageName + " has these permissions: \n").getBytes());

                    for (String permission : permissions) {
                        fosPermission.write((permission + "\n").getBytes());
//                        Log.d("Permissions", permission);
//                        Log.i("MainActivity/saveApps()", "Saved to " + getFilesDir() + "/" + FILE_NAME); //mostrar onde arquivo foi salvo
                    }
                }

            } catch (PackageManager.NameNotFoundException e) {
                e.printStackTrace();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
                Log.e("MainActivity/saveGps()", "Erro: salvar no arquivo " + packageName + ".csv");

            }
        }
    }

    public void coletarApps(){
        //coletar lista de aplicativo
        List<ApplicationInfo> applicationInfoList = getPackageManager().getInstalledApplications(PackageManager.GET_META_DATA);
        String[] stringsArray = new String[applicationInfoList.size()];
        int i = 0;
        for (ApplicationInfo applicationInfo : applicationInfoList) {
            try{
                String packageName = applicationInfo.packageName;
                stringsArray[i]  = packageName;
                PackageInfo packageInfo = getPackageManager().getPackageInfo(packageName, PackageManager.GET_PERMISSIONS);
                String[] permissions = packageInfo.requestedPermissions;
                enviaInformacoes("http://127.0.0.1:5000/predict", packageName,permissions);
                //fazerRequisicao(packageName,permissions);
//                System.out.println("\nPermissoes do"+packageName+":");
//                if (permissions != null) {
//                    for (String permission : permissions) {
//                        System.out.println(permission);
//                    }
//                }
                i++;
            } catch (PackageManager.NameNotFoundException e) {
                e.printStackTrace();
            }
        }
    }

    //metodo para quando clicar no botal "ANALISAR DADOS COLETADOS"
    public void telaDados(View view) {
        Intent intent = new Intent(getApplicationContext(), AnaliseDadosColetados.class);
        startActivity(intent);
    }

    public void infosUser(String dataAtual) {
        String FILE_NAME = "user.csv";
        FileOutputStream fos = null;
        try {
            String modelo;
            String versao;

            modelo = Build.MODEL;
            versao = Build.VERSION.RELEASE;

            fos = openFileOutput(FILE_NAME, MODE_PRIVATE);
            fos.write((modelo + "s\n").getBytes());
            fos.write((versao + "s\n").getBytes());
            fos.write((dataAtual + "s\n").getBytes());

            Log.i("MainActivity/infosUser()", "Saved to " + getFilesDir() + "/" + FILE_NAME); //mostrar onde arquivo foi salvo
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void lerDados(String FILENAME, ArrayList<String> dados) {
        FileInputStream fis = null;
        try {
            fis = openFileInput(FILENAME);
            InputStreamReader isr = new InputStreamReader(fis);
            BufferedReader br = new BufferedReader(isr);
            String lido;

            while ((lido = br.readLine()) != null) {
                dados.add(lido);
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    // Crie um método para enviar a solicitação POST com o JSON

    public void enviaInformacoes(String url, String packageName, String[] permissoes) {
        final OkHttpClient client = getUnsafeOkHttpClient();

        MediaType JSON = MediaType.parse("application/json; charset=utf-8");

        JSONObject jsonBody = new JSONObject();
        try {
            jsonBody.put("package_name", packageName);
            jsonBody.put("lista_permissoes", new JSONArray(Arrays.asList(permissoes)));
        } catch (JSONException e) {
            e.printStackTrace();
        }

        RequestBody requestBody = RequestBody.create(JSON, jsonBody.toString());

        Request request = new Request.Builder()
                .url(url + "/predict")
                .post(requestBody)
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                e.printStackTrace();
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                if (response.isSuccessful()) {
                    String responseBody = response.body().string();
                    System.out.println(responseBody);
                }
            }
        });
    }

    private OkHttpClient getUnsafeOkHttpClient() {
        try {
            final TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
            };

            final SSLContext sslContext = SSLContext.getInstance(SSL);
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());

            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

            OkHttpClient.Builder builder = new OkHttpClient.Builder();
            builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) trustAllCerts[0]);

            builder.hostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });

            return builder.build();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private void fazerRequisicao(String packageName, String[] permissoes) {
        System.out.println("Enviou Solicitação\n");
        OkHttpClient client = new OkHttpClient();
        MediaType JSON = MediaType.parse("application/json; charset=utf-8");
        try {
            // Crie o JSON com a lista de permissões
            JSONObject jsonBody = new JSONObject();
            JSONArray jsonArray = new JSONArray(Arrays.asList(permissoes));
            jsonBody.put("lista_permissoes", jsonArray);
            jsonBody.put("package_name", packageName);

            // Imprimir o JSON antes de enviar a solicitação POST
            System.out.println("JSON enviado: " + jsonBody.toString());

            // Crie o corpo da solicitação POST
            RequestBody requestBody = RequestBody.create(JSON, jsonBody.toString());

            // Crie a solicitação POST com a URL da rota
            Request request = new Request.Builder()
                    .url("http://127.0.0.1:5000/predict")
                    .post(requestBody)
                    .build();

            // Envie a solicitação para o servidor
            Response response = client.newCall(request).execute();

            if (!response.isSuccessful()) {
                System.out.println("Erro na solicitação POST");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}